
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>manta.reliability &#8212; manta 0.4.1 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for manta.reliability</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Centrality scores and cluster assignments can be tested for their reliability.</span>
<span class="sd">The idea behind this test is that random rewiring should, to some extent,</span>
<span class="sd">preserve the most central structures of the original graph.</span>
<span class="sd">We cannot know which edges are true positives and which ones are false positives,</span>
<span class="sd">but we do expect that global network properties are retained despite changes in identified associations.</span>

<span class="sd">First, null models are generated from the original graph.</span>
<span class="sd">These models are rewired copies: edge degree and connectedness are preserved.</span>
<span class="sd">Weight is assigned randomly by sampling with replacement from the original weight scores.</span>
<span class="sd">For each of these networks, the diffusion iterations specified in cluster_sparse are repeated</span>
<span class="sd">as many times as for the original network. The outcome is then a matrix of diffusion scores.</span>

<span class="sd">With these matrices, the reliability can be estimated. This error specifies how variable</span>
<span class="sd">the assignments are expected to be.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s1">&#39;Lisa Rottjers&#39;</span>
<span class="n">__email__</span> <span class="o">=</span> <span class="s1">&#39;lisa.rottjers@kuleuven.be&#39;</span>
<span class="n">__status__</span> <span class="o">=</span> <span class="s1">&#39;Development&#39;</span>
<span class="n">__license__</span> <span class="o">=</span> <span class="s1">&#39;Apache 2.0&#39;</span>


<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">manta.flow</span> <span class="k">import</span> <span class="n">diffusion</span>
<span class="kn">from</span> <span class="nn">manta.cluster</span> <span class="k">import</span> <span class="n">cluster_graph</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="k">import</span> <span class="n">binom_test</span><span class="p">,</span> <span class="n">norm</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="k">import</span> <span class="n">choice</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">logging.handlers</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>

<span class="c1"># handler to sys.stdout</span>
<span class="n">sh</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">StreamHandler</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">)</span>
<span class="n">sh</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>
<span class="n">formatter</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">Formatter</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%(asctime)s</span><span class="s1"> - </span><span class="si">%(name)s</span><span class="s1"> - </span><span class="si">%(levelname)s</span><span class="s1"> - </span><span class="si">%(message)s</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="n">sh</span><span class="o">.</span><span class="n">setFormatter</span><span class="p">(</span><span class="n">formatter</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">sh</span><span class="p">)</span>

<span class="c1"># handler to file</span>
<span class="c1"># only handler with &#39;w&#39; mode, rest is &#39;a&#39;</span>
<span class="c1"># once this handler is started, the file writing is cleared</span>
<span class="c1"># other handlers append to the file</span>
<span class="n">logpath</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">manta.log&#39;</span>
<span class="c1"># filelog path is one folder above manta</span>
<span class="c1"># pyinstaller creates a temporary folder, so log would be deleted</span>
<span class="n">fh</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">handlers</span><span class="o">.</span><span class="n">RotatingFileHandler</span><span class="p">(</span><span class="n">maxBytes</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>
                                          <span class="n">filename</span><span class="o">=</span><span class="n">logpath</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="n">fh</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>
<span class="n">formatter</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">Formatter</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%(asctime)s</span><span class="s1"> - </span><span class="si">%(name)s</span><span class="s1"> - </span><span class="si">%(levelname)s</span><span class="s1"> - </span><span class="si">%(message)s</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="n">fh</span><span class="o">.</span><span class="n">setFormatter</span><span class="p">(</span><span class="n">formatter</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">fh</span><span class="p">)</span>


<div class="viewcode-block" id="central_edge"><a class="viewcode-back" href="../../manta.html#manta.reliability.central_edge">[docs]</a><span class="k">def</span> <span class="nf">central_edge</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">percentile</span><span class="p">,</span> <span class="n">permutations</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">verbose</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The min / max values that are the result of the diffusion process</span>
<span class="sd">    are used as a centrality measure and define positive as well as negative hub associations.</span>

<span class="sd">    If the permutation number is set to a value above 0, the centrality values are tested against permuted graphs.</span>

<span class="sd">    The fraction of positive edges and negative edges is based on the ratio between</span>
<span class="sd">    positive and negative weights in the network.</span>

<span class="sd">    Hence, a network with 90 positive weights and 10 negative weights will have 90% positive hubs returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    :param graph: NetworkX graph of a microbial association network.</span>
<span class="sd">    :param percentile: Determines percentile of hub species to return.</span>
<span class="sd">    :param permutations: Number of permutations to carry out. If 0, no permutation test is done.</span>
<span class="sd">    :param error: Fraction of edges to rewire for reliability metric.</span>
<span class="sd">    :param verbose: Verbosity level of function</span>
<span class="sd">    :return: Networkx graph with hub ID / p-value as node property.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">scoremat</span> <span class="o">=</span> <span class="n">diffusion</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">negthresh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">scoremat</span><span class="p">,</span> <span class="n">percentile</span><span class="p">)</span>
    <span class="n">posthresh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">scoremat</span><span class="p">,</span> <span class="mi">100</span><span class="o">-</span><span class="n">percentile</span><span class="p">)</span>
    <span class="n">neghubs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">scoremat</span> <span class="o">&lt;=</span> <span class="n">negthresh</span><span class="p">)))</span>
    <span class="n">poshubs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">scoremat</span> <span class="o">&gt;=</span> <span class="n">posthresh</span><span class="p">)))</span>
    <span class="n">adj_index</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">)):</span>
        <span class="n">adj_index</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">)[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span>
    <span class="k">if</span> <span class="n">permutations</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">score</span> <span class="o">=</span> <span class="n">perm_edges</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">percentile</span><span class="o">=</span><span class="n">percentile</span><span class="p">,</span> <span class="n">permutations</span><span class="o">=</span><span class="n">permutations</span><span class="p">,</span>
                           <span class="n">pos</span><span class="o">=</span><span class="n">poshubs</span><span class="p">,</span> <span class="n">neg</span><span class="o">=</span><span class="n">neghubs</span><span class="p">,</span> <span class="n">error</span><span class="o">=</span><span class="n">error</span><span class="p">)</span>
    <span class="c1"># need to make sure graph is undirected</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">to_undirected</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
    <span class="c1"># initialize empty dictionary to store edge ID</span>
    <span class="n">edge_vals</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">edge_scores</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="c1"># need to convert matrix index to node ID</span>
    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">neghubs</span><span class="p">:</span>
        <span class="n">node1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">)[</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">node2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">)[</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">edge_vals</span><span class="p">[(</span><span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">)]</span> <span class="o">=</span> <span class="s1">&#39;negative hub&#39;</span>
        <span class="k">if</span> <span class="n">permutations</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">score</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">edge_scores</span><span class="p">[(</span><span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">score</span><span class="p">[(</span><span class="n">adj_index</span><span class="p">[</span><span class="n">node1</span><span class="p">],</span> <span class="n">adj_index</span><span class="p">[</span><span class="n">node2</span><span class="p">])]</span>
    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">poshubs</span><span class="p">:</span>
        <span class="n">node1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">)[</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">node2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">)[</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">edge_vals</span><span class="p">[(</span><span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">)]</span> <span class="o">=</span> <span class="s1">&#39;positive hub&#39;</span>
        <span class="k">if</span> <span class="n">permutations</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">score</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">edge_scores</span><span class="p">[(</span><span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">score</span><span class="p">[(</span><span class="n">adj_index</span><span class="p">[</span><span class="n">node1</span><span class="p">],</span> <span class="n">adj_index</span><span class="p">[</span><span class="n">node2</span><span class="p">])]</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">set_edge_attributes</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">edge_vals</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;hub&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">permutations</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">score</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">set_edge_attributes</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">edge_scores</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;reliability score&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="central_node"><a class="viewcode-back" href="../../manta.html#manta.reliability.central_node">[docs]</a><span class="k">def</span> <span class="nf">central_node</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a graph with hub edges assigned (see central_edge),</span>
<span class="sd">    this function checks whether a node is significantly more connected</span>
<span class="sd">    to edges with high scores than expected by chance.</span>
<span class="sd">    The p-value is calculated with a binomial test.</span>
<span class="sd">    Edge sign is ignored; hubs can have both positive and negative</span>
<span class="sd">    edges.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    :param graph: NetworkX graph with edge centrality scores assigned</span>
<span class="sd">    :return: NetworkX graph with hub centrality for nodes</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_edge_attributes</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s2">&quot;hub&quot;</span><span class="p">)</span>
    <span class="n">hubs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
        <span class="n">hubs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">hubs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">hubs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">hubs</span><span class="p">))</span>
    <span class="n">sighubs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">pvals</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">hubs</span><span class="p">:</span>
        <span class="n">hub_edges</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
            <span class="k">if</span> <span class="s1">&#39;hub&#39;</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">edge</span><span class="p">]:</span>
                <span class="n">hub_edges</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># given that some of the edges</span>
        <span class="c1"># this is compared to the total edge number of the node</span>
        <span class="c1"># probability is calculated by dividing total number of hub edges in graph</span>
        <span class="c1"># by total number of edges in graph</span>
        <span class="n">pval</span> <span class="o">=</span> <span class="n">binom_test</span><span class="p">(</span><span class="n">hub_edges</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]),</span>
                          <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">)),</span> <span class="n">alternative</span><span class="o">=</span><span class="s1">&#39;greater&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pval</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="p">:</span>
            <span class="n">sighubs</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;hub&#39;</span>
            <span class="n">pvals</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">pval</span><span class="p">)</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">sighubs</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;hub&#39;</span><span class="p">)</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">pvals</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;hub p-value&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="rewire_graph"><a class="viewcode-back" href="../../manta.html#manta.reliability.rewire_graph">[docs]</a><span class="k">def</span> <span class="nf">rewire_graph</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">error</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a rewired copy of the original graph.</span>
<span class="sd">    The rewiring procedure preserves degree of each node.</span>
<span class="sd">    The number of rewirings is the square of the node amount.</span>
<span class="sd">    This ensures the network is completely randomized.</span>
<span class="sd">    The weight of the edges also needs to be normalized.</span>
<span class="sd">    Therefore, after the network is randomized, weight is sampled</span>
<span class="sd">    from the original graph and added to the randomized graph.</span>
<span class="sd">    Because this does not take negative / positive hubs into account,</span>
<span class="sd">    the fraction of positive / negative weights per node</span>
<span class="sd">    is not preserved.</span>

<span class="sd">    Part of the rewire_graph function has been adapted from the original</span>
<span class="sd">    NetworkX double_edge_swap function. The adapted version also swaps edge weights.</span>

<span class="sd">    License</span>
<span class="sd">    =======</span>
<span class="sd">    NetworkX is distributed with the 3-clause BSD license.</span>
<span class="sd">    ::</span>
<span class="sd">       Copyright (C) 2004-2018, NetworkX Developers</span>
<span class="sd">       Aric Hagberg &lt;hagberg@lanl.gov&gt;</span>
<span class="sd">       Dan Schult &lt;dschult@colgate.edu&gt;</span>
<span class="sd">       Pieter Swart &lt;swart@lanl.gov&gt;</span>
<span class="sd">       All rights reserved.</span>
<span class="sd">       Redistribution and use in source and binary forms, with or without</span>
<span class="sd">       modification, are permitted provided that the following conditions are</span>
<span class="sd">       met:</span>
<span class="sd">         * Redistributions of source code must retain the above copyright</span>
<span class="sd">           notice, this list of conditions and the following disclaimer.</span>
<span class="sd">         * Redistributions in binary form must reproduce the above</span>
<span class="sd">           copyright notice, this list of conditions and the following</span>
<span class="sd">           disclaimer in the documentation and/or other materials provided</span>
<span class="sd">           with the distribution.</span>
<span class="sd">         * Neither the name of the NetworkX Developers nor the names of its</span>
<span class="sd">           contributors may be used to endorse or promote products derived</span>
<span class="sd">           from this software without specific prior written permission.</span>
<span class="sd">       THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="sd">       &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="sd">       LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<span class="sd">       A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="sd">       OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="sd">       SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="sd">       LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<span class="sd">       DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<span class="sd">       THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="sd">       (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="sd">       OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    :param graph: Original graph to rewire.</span>
<span class="sd">    :param error: Fraction of edges to rewire.</span>
<span class="sd">    :return: Rewired NetworkX graph</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">as_view</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">to_undirected</span><span class="p">(</span><span class="n">as_view</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">swaps</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">*</span> <span class="n">error</span><span class="p">)</span>
    <span class="n">swapfail</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">max_tries</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">swapcount</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">keys</span><span class="p">,</span> <span class="n">degrees</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">model</span><span class="o">.</span><span class="n">degree</span><span class="p">())</span>  <span class="c1"># keys, degree</span>
        <span class="n">cdf</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">cumulative_distribution</span><span class="p">(</span><span class="n">degrees</span><span class="p">)</span>  <span class="c1"># cdf of degree</span>
        <span class="n">discrete_sequence</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">discrete_sequence</span>
        <span class="k">while</span> <span class="n">swapcount</span> <span class="o">&lt;</span> <span class="n">swaps</span><span class="p">:</span>
            <span class="c1">#        if random.random() &lt; 0.5: continue # trick to avoid periodicities?</span>
            <span class="c1"># pick two random edges without creating edge list</span>
            <span class="c1"># choose source node indices from discrete distribution</span>
            <span class="p">(</span><span class="n">ui</span><span class="p">,</span> <span class="n">xi</span><span class="p">)</span> <span class="o">=</span> <span class="n">discrete_sequence</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">cdistribution</span><span class="o">=</span><span class="n">cdf</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ui</span> <span class="o">==</span> <span class="n">xi</span><span class="p">:</span>
                <span class="k">continue</span>  <span class="c1"># same source, skip</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">keys</span><span class="p">[</span><span class="n">ui</span><span class="p">]</span>  <span class="c1"># convert index to label</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">keys</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span>
            <span class="c1"># choose target uniformly from neighbors</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">model</span><span class="p">[</span><span class="n">u</span><span class="p">]))</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">model</span><span class="p">[</span><span class="n">x</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">y</span><span class="p">:</span>
                <span class="k">continue</span>  <span class="c1"># same target, skip</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">model</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">y</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">model</span><span class="p">[</span><span class="n">v</span><span class="p">]):</span>  <span class="c1"># don&#39;t create parallel edges</span>
                <span class="n">weight_uv</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">][</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span>
                <span class="n">weight_xy</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">][</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span>
                <span class="n">model</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
                <span class="n">model</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">][</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight_uv</span>
                <span class="n">model</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                <span class="n">model</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">v</span><span class="p">,</span> <span class="n">y</span><span class="p">][</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight_xy</span>
                <span class="n">model</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="n">model</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                <span class="n">swapcount</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="n">max_tries</span><span class="p">:</span>
                <span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Maximum number of swap attempts (</span><span class="si">%s</span><span class="s1">) exceeded &#39;</span> <span class="o">%</span> <span class="n">n</span> <span class="o">+</span>
                     <span class="s1">&#39;before desired swaps achieved (</span><span class="si">%s</span><span class="s1">).&#39;</span> <span class="o">%</span> <span class="n">swaps</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXAlgorithmError</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">except</span> <span class="n">nx</span><span class="o">.</span><span class="n">exception</span><span class="o">.</span><span class="n">NetworkXAlgorithmError</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Cannot permute this network fraction. &#39;</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span>
                     <span class="s1">&#39;Please choose a lower error parameter, or avoid calculating a centrality score. &#39;</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">swapfail</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="c1"># edge_weights = list()</span>
    <span class="c1"># for edge in graph.edges:</span>
    <span class="c1">#     edge_weights.append(graph[edge[0]][edge[1]][&#39;weight&#39;])</span>
    <span class="c1"># random_weights = dict()</span>
    <span class="c1"># for edge in model.edges:</span>
    <span class="c1">#     random_weights[edge] = choice(edge_weights)</span>
    <span class="c1"># nx.set_edge_attributes(model, random_weights, &#39;weight&#39;)</span>
    <span class="k">return</span> <span class="n">model</span><span class="p">,</span> <span class="n">swapfail</span></div>


<div class="viewcode-block" id="perm_edges"><a class="viewcode-back" href="../../manta.html#manta.reliability.perm_edges">[docs]</a><span class="k">def</span> <span class="nf">perm_edges</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">permutations</span><span class="p">,</span> <span class="n">percentile</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">neg</span><span class="p">,</span> <span class="n">error</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calls the rewire_graph function;</span>
<span class="sd">    returns reliability scores of edge centrality scores.</span>
<span class="sd">    Scores close to 100 imply that the scores are robust to perturbation.</span>
<span class="sd">    Reliability scores as proposed by:</span>
<span class="sd">    Frantz, T. L., &amp; Carley, K. M. (2017).</span>
<span class="sd">    Reporting a network’s most-central actor with a confidence level.</span>
<span class="sd">    Computational and Mathematical Organization Theory, 23(2), 301-312.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    :param graph: NetworkX graph of a microbial association network.</span>
<span class="sd">    :param permutations: Number of permutations to carry out. If 0, no bootstrapping is done.</span>
<span class="sd">    :param percentile: Determines percentile of hub species to return.</span>
<span class="sd">    :param pos: List of edges in the upper percentile. (e.g. positive hubs)</span>
<span class="sd">    :param neg: List of edges in the lower percentile. (e.g. negative hubs)</span>
<span class="sd">    :param error: Fraction of edges to rewire for reliability metric.</span>
<span class="sd">    :return: List of reliability scores.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">perms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">permutations</span><span class="p">):</span>
        <span class="n">permutation</span><span class="p">,</span> <span class="n">swapfail</span> <span class="o">=</span> <span class="n">rewire_graph</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">swapfail</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">adj</span> <span class="o">=</span> <span class="n">diffusion</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="n">permutation</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">perms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">adj</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Permutation &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
    <span class="n">posmatches</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">negmatches</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">hub</span> <span class="ow">in</span> <span class="n">pos</span><span class="p">:</span>
        <span class="n">posmatches</span><span class="p">[</span><span class="n">hub</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">hub</span> <span class="ow">in</span> <span class="n">neg</span><span class="p">:</span>
        <span class="n">negmatches</span><span class="p">[</span><span class="n">hub</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">perm</span> <span class="ow">in</span> <span class="n">perms</span><span class="p">:</span>
        <span class="n">negthresh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">perm</span><span class="p">,</span> <span class="n">percentile</span><span class="p">)</span>
        <span class="n">posthresh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">perm</span><span class="p">,</span> <span class="mi">100</span> <span class="o">-</span> <span class="n">percentile</span><span class="p">)</span>
        <span class="n">permneg</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">perm</span> <span class="o">&lt;=</span> <span class="n">negthresh</span><span class="p">)))</span>
        <span class="n">permpos</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">perm</span> <span class="o">&gt;=</span> <span class="n">posthresh</span><span class="p">)))</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">permpos</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">:</span>
            <span class="n">posmatches</span><span class="p">[</span><span class="n">match</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">neg</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">permneg</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">:</span>
            <span class="n">negmatches</span><span class="p">[</span><span class="n">match</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">reliability</span> <span class="o">=</span> <span class="n">posmatches</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">reliability</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">negmatches</span><span class="p">)</span>
    <span class="n">reliability</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span><span class="o">/</span><span class="n">permutations</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">reliability</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="c1"># p value equals number of permutations that exceeds / is smaller than matrix values</span>
    <span class="k">return</span> <span class="n">reliability</span></div>


<div class="viewcode-block" id="perm_clusters"><a class="viewcode-back" href="../../manta.html#manta.reliability.perm_clusters">[docs]</a><span class="k">def</span> <span class="nf">perm_clusters</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">max_clusters</span><span class="p">,</span> <span class="n">min_clusters</span><span class="p">,</span> <span class="n">min_cluster_size</span><span class="p">,</span>
                  <span class="n">iterations</span><span class="p">,</span> <span class="n">ratio</span><span class="p">,</span> <span class="n">partialperms</span><span class="p">,</span> <span class="n">relperms</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">verbose</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calls the rewire_graph function and robustness function</span>
<span class="sd">    to compute robustness of cluster assignments.</span>
<span class="sd">    Scores close to 1 imply that the scores are robust to perturbation.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    :param graph: NetworkX graph of a microbial association network. Cluster assignment should be a network property.</span>
<span class="sd">    :param limit: Percentage in error decrease until matrix is considered converged.</span>
<span class="sd">    :param max_clusters: Maximum number of clusters to evaluate in K-means clustering.</span>
<span class="sd">    :param min_clusters: Minimum number of clusters to evaluate in K-means clustering.</span>
<span class="sd">    :param min_cluster_size: Minimum cluster size as fraction of network size</span>
<span class="sd">    :param iterations: If algorithm does not converge, it stops here.</span>
<span class="sd">    :param ratio: Ratio of scores that need to be positive or negative for a stable edge</span>
<span class="sd">    :param partialperms: Number of permutations for partial diffusion.</span>
<span class="sd">    :param relperms: Number of permutations for reliability testing.</span>
<span class="sd">    :param error: Fraction of edges to rewire for reliability metric.</span>
<span class="sd">    :param verbose: Verbosity level of function</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">assignments</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">rev_assignments</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">relperms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dyadicpairs</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">keys</span><span class="p">,</span> <span class="n">degrees</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">graph</span><span class="o">.</span><span class="n">degree</span><span class="p">())</span>  <span class="c1"># keys, degree</span>
        <span class="k">for</span> <span class="n">deg</span> <span class="ow">in</span> <span class="n">degrees</span><span class="p">:</span>
            <span class="n">num_nodes</span> <span class="o">=</span> <span class="n">degrees</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">deg</span><span class="p">)</span>
            <span class="n">dyadicpairs</span> <span class="o">+=</span> <span class="p">(</span><span class="n">num_nodes</span><span class="o">*</span><span class="p">(</span><span class="n">num_nodes</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">numswaps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span> <span class="o">*</span> <span class="n">error</span>
        <span class="c1"># given a set of possible swaps,</span>
        <span class="c1"># and a desired number of swaps</span>
        <span class="c1"># swaps may be repeated (a-b c-d to a-c b-d and back)</span>
        <span class="c1"># possible number of permutations:</span>
        <span class="c1"># p = n! / (n - r)!</span>
        <span class="c1"># this number is much too large</span>
        <span class="n">relperms</span> <span class="o">=</span> <span class="n">dyadicpairs</span> <span class="o">/</span> <span class="n">numswaps</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">relperms</span><span class="p">):</span>
        <span class="n">permutation</span><span class="p">,</span> <span class="n">swapfail</span> <span class="o">=</span> <span class="n">rewire_graph</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">swapfail</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">permutation</span><span class="p">,</span> <span class="n">mat</span> <span class="o">=</span> <span class="n">cluster_graph</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="n">permutation</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">max_clusters</span><span class="o">=</span><span class="n">max_clusters</span><span class="p">,</span>
                                         <span class="n">min_clusters</span><span class="o">=</span><span class="n">min_clusters</span><span class="p">,</span> <span class="n">min_cluster_size</span><span class="o">=</span><span class="n">min_cluster_size</span><span class="p">,</span>
                                         <span class="n">iterations</span><span class="o">=</span><span class="n">iterations</span><span class="p">,</span>
                                         <span class="n">ratio</span><span class="o">=</span><span class="n">ratio</span><span class="p">,</span> <span class="n">edgescale</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">permutations</span><span class="o">=</span><span class="n">partialperms</span><span class="p">,</span>
                                         <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">cluster</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">permutation</span><span class="p">,</span> <span class="s1">&#39;cluster&#39;</span><span class="p">)</span>
        <span class="c1"># cluster.values() has same order as permutation.nodes</span>
        <span class="n">assignments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
        <span class="n">subassignments</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">cluster</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">subassignments</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="n">rev_assignments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subassignments</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Permutation &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
    <span class="n">graphclusters</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s1">&#39;cluster&#39;</span><span class="p">)</span>
    <span class="n">clusjaccards</span><span class="p">,</span> <span class="n">nodejaccards</span><span class="p">,</span> <span class="n">ci_width</span> <span class="o">=</span> <span class="n">robustness</span><span class="p">(</span><span class="n">graphclusters</span><span class="p">,</span> <span class="n">assignments</span><span class="p">)</span>
    <span class="n">lowerCI</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">upperCI</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodejaccards</span><span class="p">:</span>
        <span class="n">lowerCI</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asscalar</span><span class="p">(</span><span class="n">nodejaccards</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">upperCI</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asscalar</span><span class="p">(</span><span class="n">nodejaccards</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">ci_width</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asscalar</span><span class="p">(</span><span class="n">ci_width</span><span class="p">[</span><span class="n">node</span><span class="p">])</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">lowerCI</span><span class="p">,</span> <span class="s2">&quot;lowerCI&quot;</span><span class="p">)</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">upperCI</span><span class="p">,</span> <span class="s2">&quot;upperCI&quot;</span><span class="p">)</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">ci_width</span><span class="p">,</span> <span class="s2">&quot;widthCI&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Completed estimation of node Jaccard similarities across bootstraps.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="robustness"><a class="viewcode-back" href="../../manta.html#manta.reliability.robustness">[docs]</a><span class="k">def</span> <span class="nf">robustness</span><span class="p">(</span><span class="n">graphclusters</span><span class="p">,</span> <span class="n">permutations</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compares vectors of cluster assignments to estimate cluster-wise robustness</span>
<span class="sd">    and node-wise robustness. These are returned as dictionaries.</span>

<span class="sd">    Inspired by reliablity scores as proposed by:</span>
<span class="sd">    Frantz, T. L., &amp; Carley, K. M. (2017).</span>
<span class="sd">    Reporting a network’s most-central actor with a confidence level.</span>
<span class="sd">    Computational and Mathematical Organization Theory, 23(2), 301-312.</span>

<span class="sd">    Because calculating the accuracy of a cluster assignment is not trivial,</span>
<span class="sd">    the function does not compare cluster labels directly.</span>
<span class="sd">    Instead, this function calculates the Jaccard similarity between cluster assignments.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    :param graphclusters: Dictionary of original cluster assignments</span>
<span class="sd">    :param permutations: Number of permutations to compute robustness.</span>
<span class="sd">    :return: Two dictionaries of reliability scores (cluster-wise and node-wise).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rev_assignments</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">assignment</span> <span class="ow">in</span> <span class="n">permutations</span><span class="p">:</span>
        <span class="n">subassignments</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">assignment</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">subassignments</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="n">rev_assignments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subassignments</span><span class="p">)</span>
    <span class="n">revclusters</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">graphclusters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">revclusters</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="c1"># clusterwise jaccard</span>
    <span class="n">clusjaccards</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">graphclusters</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
        <span class="n">true_composition</span> <span class="o">=</span> <span class="n">revclusters</span><span class="p">[</span><span class="n">cluster</span><span class="p">]</span>
        <span class="n">jaccards</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="c1"># keys don&#39;t have to match so both cluster assignments should be evaluated</span>
        <span class="k">for</span> <span class="n">rev_assignment</span> <span class="ow">in</span> <span class="n">rev_assignments</span><span class="p">:</span>
            <span class="n">scores</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">rev_assignment</span><span class="p">:</span>
                <span class="n">scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jaccard_similarity_score</span><span class="p">(</span><span class="n">true_composition</span><span class="p">,</span> <span class="n">rev_assignment</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>
            <span class="n">bestmatch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span>
            <span class="n">jaccards</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bestmatch</span><span class="p">)</span>
        <span class="n">clusjaccards</span><span class="p">[</span><span class="n">cluster</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">norm</span><span class="o">.</span><span class="n">interval</span><span class="p">(</span><span class="mf">0.95</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">jaccards</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">jaccards</span><span class="p">)),</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Confidence intervals for Jaccard similarity of cluster assignments:&quot;</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">clusjaccards</span><span class="p">))</span>
    <span class="n">nodejaccards</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">graphclusters</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">ci_width</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">graphclusters</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodejaccards</span><span class="p">:</span>
        <span class="n">true_composition</span> <span class="o">=</span> <span class="n">revclusters</span><span class="p">[</span><span class="n">graphclusters</span><span class="p">[</span><span class="n">node</span><span class="p">]]</span>
        <span class="n">jaccards</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">permutations</span><span class="p">)):</span>
            <span class="n">clusid</span> <span class="o">=</span> <span class="n">permutations</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">node</span><span class="p">]</span>
            <span class="n">rev_assignment</span> <span class="o">=</span> <span class="n">rev_assignments</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">clusid</span><span class="p">]</span>
            <span class="n">jaccards</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jaccard_similarity_score</span><span class="p">(</span><span class="n">true_composition</span><span class="p">,</span> <span class="n">rev_assignment</span><span class="p">))</span>
        <span class="n">nodejaccards</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">norm</span><span class="o">.</span><span class="n">interval</span><span class="p">(</span><span class="mf">0.95</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">jaccards</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">jaccards</span><span class="p">)),</span> <span class="mi">4</span><span class="p">)</span>
        <span class="n">ci_width</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">nodejaccards</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">nodejaccards</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="mi">4</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">clusjaccards</span><span class="p">,</span> <span class="n">nodejaccards</span><span class="p">,</span> <span class="n">ci_width</span></div>


<div class="viewcode-block" id="jaccard_similarity_score"><a class="viewcode-back" href="../../manta.html#manta.reliability.jaccard_similarity_score">[docs]</a><span class="k">def</span> <span class="nf">jaccard_similarity_score</span><span class="p">(</span><span class="n">vector1</span><span class="p">,</span> <span class="n">vector2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The sklearn implementation of the Jaccard similarity requires vectors to be equal length.</span>
<span class="sd">    This implementation does not.</span>
<span class="sd">    :param vector1: List of strings or numbers.</span>
<span class="sd">    :param vector2: List of strings or numbers.</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">jaccard</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vector1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">vector2</span><span class="p">))</span> <span class="o">/</span> \
              <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vector1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">vector2</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">vector1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">vector2</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">jaccard</span></div>

</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">manta</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Lisa Rottjers.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    

    
  </body>
</html>